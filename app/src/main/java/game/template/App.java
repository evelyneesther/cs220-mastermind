/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package game.template;

import java.net.URL;
import java.util.Arrays;

import javafx.application.Application;
import javafx.collections.ObservableList;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuBar;
import javafx.scene.control.MenuItem;
import javafx.scene.control.TextField;
import javafx.scene.image.ImageView;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;
import java.util.Random;

public class App extends Application
{
    private static final int SIZE = 8;
    // this is the size of each square in the chess or checkers board
    // this must be kept in sync with the size of the images, and the
    // size of the squares in the css file
    private static final int SQUARE_SIZE = 70;
    private VBox root;
    // using StackPane so that they can hold a rectangle and an image
    // we use the rectangle to color the squares
    // and the image to place the pieces
    private StackPane[][] grid = new StackPane[12][12];

    private Integer[][] colorGrid=new Integer[8][12];
    private int turn=0;
    private int[] code=new int[4];
    private boolean endless=false;

    @Override
    public void start(Stage primaryStage) throws Exception
    {
        root = new VBox();

        root.getChildren().add(createMenuBar());

        GridPane gridPane = new GridPane();
        // preferred size of the gridpane
        gridPane.setPrefSize(SQUARE_SIZE * 8, SQUARE_SIZE * 12);

        root.getChildren().add(gridPane);

        for (int i=0; i<8; i++)
        {
            Arrays.fill(colorGrid[i], -1);
        }

        // loosely based on https://stackoverflow.com/questions/69339314/how-can-i-draw-over-a-gridpane-of-rectangles-with-an-image-javafx
        for (int row = 0; row < 12; row++)
        {
            for (int col = 0; col < 9; col++)
            {

                StackPane cell;

                if (col==4){
                    Rectangle rect = new Rectangle(SQUARE_SIZE, SQUARE_SIZE);
                    rect.getStyleClass().add("square-2");
                    cell = new StackPane(rect);
                } else {
                    Circle circ=new Circle(SQUARE_SIZE/2);
                    circ.getStyleClass().add("dot-blank");
                    cell = new StackPane(circ);
                }


                grid[row][col] = cell;

                // name each cell with its row and column
                // unsure we'll need this
                cell.setId(row + "-" + col);

                // we need to create these extra local final variables
                // I think this has to do with thread safety?
                final int r = row;
                final int c = col;
                // make each cell clickable
                cell.setOnMouseClicked(event -> handleMouseClick(event, r, c));

                // finally, put the stackpane into the gridpane
                gridPane.add(cell, col, row);

            }
        }
        Random random = new Random();
        int[] code = new int[4];
        for (int i = 0; i < 4; i++) {
            code[i] = random.nextInt(6);
        }
        System.out.println(Arrays.toString(code));


        // don't give a width or height to the scene
        // it will figure it out because there's a menu bar
        // plus each square is a fixed size
        Scene scene = new Scene(root);

        // add style information
        URL styleURL = getClass().getResource("/style.css");
        String stylesheet = styleURL.toExternalForm();
        scene.getStylesheets().add(stylesheet);

        // set title and scene and show to the user
        primaryStage.setTitle("GAME TEMPLATE");
        primaryStage.setScene(scene);
        primaryStage.show();

        // handler for when we click the close button
        primaryStage.setOnCloseRequest(event -> {
            System.out.println("oncloserequest");
        });
        scene.setOnKeyPressed(event -> {
            System.out.println("Key pressed: " + event.getCode());
            switch (event.getCode()) {
                // check for the key input
                case ESCAPE:
                    // remove focus from the textfields by giving it to the root VBox
                    root.requestFocus();
                    break;
                case ENTER:
                    int corrPosColor = 0;
                    int incorrPosColor = 0;
                    for (int c = 0; c < 4; c++) {
                        if (colorGrid[turn][c] == -1) {
                            Alert alert = new Alert(Alert.AlertType.INFORMATION);
                            alert.setTitle("Invalid Solution");
                            alert.setHeaderText(null);
                            alert.setContentText("Make sure all pegs are selected!");
                            alert.showAndWait();
                        }
                    }
                    boolean[] used = new boolean[4];
                    Arrays.fill(used, false);

                    for (int c = 0; c < 4; c++) {
                        if (code[c] == colorGrid[turn][c]) {
                            corrPosColor++;
                            used[c] = true;
                        } else {
                            for (int i = 0; i < 4; i++) {
                                if (code[c] == colorGrid[turn][i]&&!used[i]) {
                                    incorrPosColor++;
                                }
                            }
                        }
                    }
                    System.out.println("Correct position and color: " + corrPosColor);
                    System.out.println("Incorrect position and correct color: " + incorrPosColor);
                    if (corrPosColor == 4) {
                        Alert alert = new Alert(Alert.AlertType.INFORMATION);
                        alert.setTitle("Congratulations!");
                        alert.setHeaderText(null);
                        alert.setContentText("You win!");
                        alert.showAndWait();
                    }
                    for (int c = 5; c < 9; c++) {
                        if (corrPosColor > 0) {
                            Circle blackPeg = new Circle(SQUARE_SIZE / 2);
                            blackPeg.getStyleClass().add("dot-black");
                            grid[turn][c].getChildren().add(blackPeg);
                            corrPosColor--;
                        } else if (incorrPosColor > 0) {
                            Circle whitePeg = new Circle(SQUARE_SIZE / 2);
                            whitePeg.getStyleClass().add("dot-white");
                            grid[turn][c].getChildren().add(whitePeg);
                            incorrPosColor--;
                        }
                        else {
                            grid[turn][c].getChildren().clear();
                        }
                    }
                    // Code matches, handle accordingly
                    // ...
                    turn++;
                    if (turn == 12) {
                        Alert alert = new Alert(Alert.AlertType.INFORMATION);
                        alert.setTitle("Game Over");
                        alert.setHeaderText(null);
                        alert.setContentText("You lose!");
                        alert.showAndWait();
                    }
                    break;
                case R:
                    for (int col = 0; col < 12; col++) {
                        if (col != 4) {
                            Circle blankPeg = new Circle(SQUARE_SIZE / 2);
                            blankPeg.getStyleClass().add("dot-blank");
                            grid[turn][col].getChildren().add(blankPeg);
                        }
                    }
                    break;
                default:
                    System.out.println("you typed key: " + event.getCode());
                    break;

            }
        });
        showControls();
    }
    private void clearBoard()
    {
        // removes all of the images (pieces) from the board
        for (int row = 0; row < SIZE; row++)
        {
            for (int col = 0; col < SIZE; col++)
            {
                grid[row][col].getChildren().removeIf(child -> child instanceof ImageView);
            }
        }
    }

    private void drawBoard1()
    {
        clearBoard();
        placePiece(Player.WHITE, ChessPiece.PAWN, 1, 0);
        placePiece(Player.WHITE, ChessPiece.PAWN, 2, 0);
        placePiece(Player.BLACK, ChessPiece.ROOK, 3, 0);
        placePiece(Player.BLACK, ChessPiece.QUEEN, 4, 0);
    }

    private void drawBoard2()
    {
        clearBoard();
        placePiece(Player.WHITE, ChessPiece.PAWN, 1, 4);
        placePiece(Player.WHITE, ChessPiece.PAWN, 2, 4);
        placePiece(Player.BLACK, ChessPiece.ROOK, 3, 4);
        placePiece(Player.BLACK, ChessPiece.QUEEN, 4,4);
    }

    private void handleMouseClick(MouseEvent event, int row, int col)
    {
        if (col>=4){
            return;
        };
        Circle circle = new Circle(SQUARE_SIZE / 2);
        colorGrid[row][col]++;
        circle.getStyleClass().add(getDotColor(row, col));
        grid[row][col].getChildren().add(circle);
    }

    private void placePiece(Player player, ChessPiece piece, int row, int col)
    {
        String imageName = "";
        if (player == Player.WHITE)
        {
            imageName = "w" + piece.toString().toLowerCase() + ".png";
        }
        else
        {
            imageName = "b" + piece.toString().toLowerCase() + ".png";
        }
        ImageView image = loadImage(imageName);
        // add the image to the cell
        // each cell is stack pane so that we can "stack" the piece
        // on top of the rectangle for the square
        grid[row][col].getChildren().add(image);
        // not sure if any of this was necessary; commenting it out didn't seem to matter
        image.setFitWidth(SQUARE_SIZE);
        image.setFitHeight(SQUARE_SIZE);
        //image.fitWidthProperty().bind(grid[row][col].widthProperty().subtract(2));
        //image.fitHeightProperty().bind(grid[row][col].heightProperty().subtract(2));
    }

    private ImageView loadImage(String name)
    {
        return new ImageView(getClass().getResource("/assets/" + name).toExternalForm());
    }

    private MenuBar createMenuBar()
    {
        MenuBar menuBar = new MenuBar();
        menuBar.getStyleClass().add("menubar");

        //
        // File Menu
        //
        Menu modeMenu = new Menu("Controls");
        addMenuItem(modeMenu, "Show Controls", () -> {
            showControls();
        });
        menuBar.getMenus().add(modeMenu);

        return menuBar;
    }

    private void addMenuItem(Menu menu, String name, Runnable action)
    {
        MenuItem menuItem = new MenuItem(name);
        menuItem.setOnAction(event -> action.run());
        menu.getItems().add(menuItem);
    }

    public static void main(String[] args)
    {
        launch(args);
    }

    private String getDotColor(int row, int col) {
        String[] dotColors = {"dot-red", "dot-blue", "dot-green", "dot-yellow", "dot-cyan", "dot-purple"};
        int index = colorGrid[row][col] % dotColors.length;
        return dotColors[index];
    }

    private void showControls(){
        Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setTitle("Controls");
        alert.setHeaderText(null);
        alert.setContentText("Click on a peg to change it's color, press enter to submit your guess. Use R to clear your current line. Black pegs indicate correct color and position, white pegs indicate correct color but wrong position. You have 12 turns to guess the code.");
        alert.showAndWait();
    }
}
